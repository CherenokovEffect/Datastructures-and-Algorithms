LEVEL 1 â€” Linear Recursion (warmup)

These give base case intuition.

Sum of array using recursion                       Done

Max/min in array recursion

Reverse array recursively                          Done

Print numbers 1â†’N and Nâ†’1

Factorial                                          Done

Fibonacci (simple)                                 Done

ðŸ‘‰ Goal: understand base cases and return types.

ðŸŸ¡ LEVEL 2 â€” Tree Recursion (2 recursive calls)

You need these before going to subsets/permutations.

Fibonacci optimized (memo later)

Count ways to climb stairs (2^n tree)

Count subsets (just count, not generate)

ðŸ‘‰ Goal: learn branching recursion.

ðŸ”µ LEVEL 3 â€” Backtracking Fundamentals (state change â†’ undo)

These give the core backtracking muscle.

Print all binary strings of length N

Print all subsets (power set)

Subset sum (print subsets whose sum = K)

Count subsets with sum K

Print all combinations that sum to K

Generate all strings from keypad mapping (like phone digits)

ðŸ‘‰ Here you learn push â†’ recurse â†’ pop.

ðŸ”´ LEVEL 4 â€” Classic Backtracking (heavy)

All permutations of array

Permutations with duplicates (using bool arrays / sorting)

Combinations of k out of n

N-Queens

Rat in a maze

Sudoku solver

Letter case permutations

All valid parentheses

Restore IP addresses

Word search on board (DFS)

ðŸ‘‰ After this: subsets/permutations feel EASY.

ðŸŸ£ LEVEL 5 â€” Recursion used for DP (Memoization)

This is where recursion becomes useful in CF/LC DP.

Fibonacci (memo)

Climbing stairs with memo

Grid paths (m x n)

Minimum cost path (memo)

Coin change (ways)

Coin change (min coins)

Longest Increasing Subsequence (LIS) â€“ recursive DP

Longest Common Subsequence (LCS) â€“ recursive DP

Edit distance â€“ recursive DP

DP on trees (like subtree sums, distances)

ðŸ‘‰ Learn:

recursion + memo table

recognizing overlapping subproblems

turning recursion into DP

ðŸŸ¤ LEVEL 6 â€” Competitive Programming Recursion & DFS

DFS on graph

Tree DFS (inorder, preorder, postorder)

Subtree size of each node

Height of a tree

Diameter of a tree

Count paths in tree

DP on trees (rooted tree DP)

Backtracking on grids

All paths in DAG using recursion

ðŸŸ¢ Finally â€” Mastery level recursion

All hard DP problems start with recursion:

knapsack

unbounded knapsack

partition equal subset

matrix chain multiplication

palindrome partitioning

DP on subsequences

Why you struggle with subsets, permutations, and Hanoi

These are all 2^n problems â€” recursion trees explode:

subsets â†’ height = n, nodes = 2^n

permutations â†’ n! calls

Tower of Hanoi â†’ 2^n âˆ’ 1 moves